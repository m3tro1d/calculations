# ---------------------- Model "UniCar": CruizControl --------------------
""" В данном модуле описывается изменение положения робота на плоскости """
"""
Авторобот с двумя управляемыми колесами (рис.1) находится в точке r0=(x0,y0) и глядит в направлении φ0. 
Робот может перемещаться при заданных ограничениях на допустимые угловые скорости вращения колес wmin и wmax (рад/с)

Наблюдаемые параметры (состояние робота) - координаты робота xC, yC, φ (координаты центра робота + направление движения) 
- получаем от GPS-навигатора и компаса. 

Управляющие воздействия - wL,wR - угловая скорость вращения левого и правого колес 
(моментом инерции и трением пренебрегаем из-за небольших скоростей).

Зная wL, wR, можно рассчитать линейную скорость центра робота Vc и скорость вращения вокруг центральной оси ωC, 
используя следующие соотношения:
Vc=((wL+wR)*R)/2=(vL+vR)/2,
wC=((wL-wR)*R)/L=(vL-vR)/L
Зная Vc - линейная скорость центра масс и wC - угловая скорость вращения робота вокруг его центра, можно рассчитать 
изменение состояния робота xC, yC, φ (координаты центра робота + направление движения)
"""
# --------------- подгружаем необходимые библиотеки и модули ------------------
import numpy as np
import math

# -----------------------------------------------------------------------------
# нормализация значений WL, WR, чтобы ROBOT_Wmin <= WR,WL <= ROBOT_Wmax
# -----------------------------------------------------------------------------
def clampW(W, Wmin, Wmax):
    return min(max(W, Wmin), Wmax)

# -----------------------------------------------------------------------------
# вычисление значений vC, wC по взначениям wR,wL
# -----------------------------------------------------------------------------
def calcVW(wL, wR, ROBOT_L, ROBOT_R):
    vC = (wL+wR)*ROBOT_R / 2
    wC = (wR - wL) * ROBOT_R / ROBOT_L
    return vC, wC

# -------------------------------------------------------------------------------------------------------
# вычисление значений wR,wL по взначениям vC, wC
# -------------------------------------------------------------------------------------------------------
def calcWLWR(vC, wC, ROBOT_L, ROBOT_R):
    wR = (2*vC / ROBOT_R + wC*ROBOT_L / ROBOT_R) / 2
    wL = (2*vC / ROBOT_R - wC*ROBOT_L / ROBOT_R) / 2
    return wL, wR

# ----------------------------------------------------------------------------
# изменение состояния робота по известному управлению
# ----------------------------------------------------------------------------
def change_robot_state(robot_state, model_pars, dt, wL, wR, printing=False):
    lastT, lastX, lastY, lastFi = robot_state[-1]
    wL = clampW(wL, model_pars['ROBOT_Wmin'], model_pars['ROBOT_Wmax'])
    wR = clampW(wR, model_pars['ROBOT_Wmin'], model_pars['ROBOT_Wmax'])
    vC, wC = calcVW(wL, wR, model_pars['ROBOT_L'], model_pars['ROBOT_R'])
    dFi = wC * dt
    dX = vC* math.cos(lastFi+dFi/2)*dt
    dY = vC * math.sin(lastFi+dFi/2) * dt
    newState = np.array([lastT+dt, lastX+dX, lastY+dY, lastFi+dFi])
    # каждое новое состояние добавляем как новую строку в массиве ROBOT_state
    robot_state = np.vstack([robot_state, newState])
    if printing: print('Новое состояние робота: ', newState)
    return robot_state
